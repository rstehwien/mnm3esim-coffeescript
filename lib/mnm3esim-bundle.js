// Generated by CoffeeScript 1.4.0
(function() {
  var Attack, AttackResult, Character, CharacterEffect, Defense, Modifiable, ResistResult, Status, StatusModifier, Utils, utils, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Modifiable = require('./modifiable.coffee').Modifiable;

  Status = require('../src/status.coffee').Status;

  AttackResult = (function(_super) {

    __extends(AttackResult, _super);

    function AttackResult(values) {
      var properties;
      if (values == null) {
        values = {};
      }
      properties = {
        attack: null,
        damage: 0,
        damageImpervious: 0,
        d20: 0,
        roll: 0,
        isCrit: false,
        degree: -1
      };
      AttackResult.__super__.constructor.call(this, null, properties, values);
      if (this.attack != null) {
        if (!(values.damage != null)) {
          this.damage = this.attack.rank;
        }
        if (!(values.damageImpervious != null)) {
          this.damageImpervious = this.attack.rank;
        }
      }
    }

    return AttackResult;

  })(Modifiable);

  Attack = (function(_super) {

    __extends(Attack, _super);

    function Attack(values) {
      var modifiable, properties;
      if (values == null) {
        values = {};
      }
      modifiable = {
        bonus: 10,
        rank: 10
      };
      properties = {
        penetrating: 0,
        minCrit: 20,
        isCauseStress: true,
        isPerceptionAttack: false,
        isStatusRecovery: false,
        isProgressive: false,
        isMultiattack: false,
        cumulativeStatuses: ['staggered'],
        statuses: ['dazed', 'staggered', 'incapacitated']
      };
      Attack.__super__.constructor.call(this, modifiable, properties, values);
    }

    Attack.DEFAULTS_DAMAGE = {
      bonus: 10,
      rank: 10,
      penetrating: 0,
      minCrit: 20,
      isCauseStress: true,
      isPerceptionAttack: false,
      isStatusRecovery: false,
      isProgressive: false,
      isMultiattack: false,
      cumulativeStatuses: ['staggered'],
      statuses: ['dazed', 'staggered', 'incapacitated']
    };

    Attack.DEFAULTS_AFFLICTION = {
      bonus: 10,
      rank: 10,
      penetrating: 0,
      minCrit: 20,
      isCauseStress: false,
      isPerceptionAttack: false,
      isStatusRecovery: true,
      isProgressive: false,
      isMultiattack: false,
      cumulativeStatuses: [],
      statuses: ['impaired', 'disabled', 'incapacitated']
    };

    Attack.createDamage = function(values) {
      if (values == null) {
        values = {};
      }
      return new Attack(_.extend(Attack.DEFAULTS_DAMAGE, values));
    };

    Attack.createAffliction = function(values) {
      if (values == null) {
        values = {};
      }
      return new Attack(_.extend(Attack.DEFAULTS_AFFLICTION, values));
    };

    Attack.prototype.statusByResistDegree = function(degree) {
      if (degree > 0) {
        return Status.getStatus('normal');
      }
      return this.statusByDegree(Math.abs(degree));
    };

    Attack.prototype.statusByDegree = function(degree) {
      if (degree < 1) {
        return Status.getStatus('normal');
      }
      return Status.getStatus(this.statuses[Math.min(degree, this.statuses.length) - 1]);
    };

    Attack.prototype.attack = function(defense) {
      var hit;
      hit = new AttackResult({
        attack: this,
        degree: -1
      });
      if (this.isPerceptionAttack) {
        hit.degree = 1;
        return hit;
      }
      hit.d20 = this.rollCheck();
      hit.roll = hit.d20 + this.bonus;
      if (hit.d20 === 1) {
        return hit;
      }
      hit.degree = this.checkDegree(defense.value + 10, hit.roll);
      hit.isCrit = hit.degree > 0 && hit.d20 >= this.minCrit;
      if (hit.d20 === 20 && hit.degree < 1) {
        hit.degree = 1;
      }
      if (hit.degree < 0) {
        return hit;
      }
      if (hit.isCrit) {
        hit.damage += 5;
        hit.damageImpervious += 5;
      }
      if (this.isMultiattack && hit.degree > 1) {
        hit.damage += (hit.degree >= 3 ? 5 : 2);
      }
      return hit;
    };

    return Attack;

  })(Modifiable);

  module.exports = {
    Attack: Attack,
    AttackResult: AttackResult
  };

  Modifiable = require('./modifiable.coffee').Modifiable;

  utils = require('./utils.coffee').utils;

  Status = require('../src/status.coffee').Status;

  CharacterEffect = (function(_super) {

    __extends(CharacterEffect, _super);

    function CharacterEffect(values) {
      var properties;
      if (values == null) {
        values = {};
      }
      properties = {
        attack: null,
        defense: null,
        status: null,
        degree: null
      };
      CharacterEffect.__super__.constructor.call(this, null, properties, values);
      if ((!(values.degree != null)) && (values.status != null)) {
        this.degree = values.status.degree;
      }
      if ((!(values.status != null)) && (values.attack != null) && (values.degree != null)) {
        this.status = values.attack.statusByDegree(values.degree);
      }
    }

    return CharacterEffect;

  })(Modifiable);

  Character = (function(_super) {

    __extends(Character, _super);

    function Character(values) {
      var modifiable, properties;
      if (values == null) {
        values = {};
      }
      modifiable = {
        initiative: 0,
        actions: 'full',
        isControlled: false,
        speed: 0
      };
      properties = {
        name: "Character",
        attack: null,
        defense: null,
        stress: 0,
        stressDegree: 0,
        status: null,
        effects: {}
      };
      Character.__super__.constructor.call(this, modifiable, properties, values);
      this.initCombat();
    }

    Character.prototype.initCombat = function() {
      this.stress = 0;
      this.actions = 'full';
      this.isControlled = false;
      this.effects = {};
      this.updateStatus();
      return this.initiativeValue = this.rollCheck(this.initiative);
    };

    Character.prototype.updateStatus = function() {
      var combined, effect, groups, k, m, statuses, uid, v, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _results;
      _ref = (function() {
        var _ref, _results;
        _ref = this.effects;
        _results = [];
        for (k in _ref) {
          if (!__hasProp.call(_ref, k)) continue;
          v = _ref[k];
          if (v.status.degree < 1) {
            _results.push(k);
          }
        }
        return _results;
      }).call(this);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        uid = _ref[_i];
        delete this.effects[uid];
      }
      statuses = (function() {
        var _ref1, _results;
        _ref1 = this.effects;
        _results = [];
        for (k in _ref1) {
          if (!__hasProp.call(_ref1, k)) continue;
          effect = _ref1[k];
          _results.push(effect.status.key);
        }
        return _results;
      }).call(this);
      combined = Status.combinedStatus(statuses);
      this.status = combined.statuses;
      this.statusDegree = combined.degree;
      this.clearModifiers();
      if ((_ref1 = this.attack) != null) {
        _ref1.clearModifiers();
      }
      if ((_ref2 = this.defense) != null) {
        _ref2.clearModifiers();
      }
      _ref3 = combined.modifiers;
      _results = [];
      for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
        m = _ref3[_j];
        groups = utils.makeArray(m.group);
        if (__indexOf.call(groups, 'ALL') >= 0) {
          groups = ['character', 'attack', 'defense'];
        }
        if (__indexOf.call(groups, 'character') >= 0) {
          this.addModifier(m.property, m.modifier);
        }
        if (__indexOf.call(groups, 'attack') >= 0) {
          if ((_ref4 = this.attack) != null) {
            _ref4.addModifier(m.property, m.modifier);
          }
        }
        if (__indexOf.call(groups, 'defense') >= 0) {
          _results.push((_ref5 = this.defense) != null ? _ref5.addModifier(m.property, m.modifier) : void 0);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Character.prototype.attack = function(target) {
      if (!(this.attack != null) || !((target != null ? target.defense : void 0) != null)) {
        return;
      }
      return target.applyHit(this.attack.attack(target.defense));
    };

    Character.prototype.applyHit = function(hit) {
      var cumulativeStatuses, curStatus, newStatus, resist, _ref, _ref1;
      if (hit.degree < 0) {
        return;
      }
      resist = this.defense.resistHit(hit, this.stress);
      if (resist.stress < 1 && (!(resist.status != null) || resist.status.degree < 1)) {
        return;
      }
      this.stress += resist.stress;
      if (!(resist.status != null) || resist.status.degree < 1) {
        return;
      }
      curStatus = this.effects[hit.attack.uid] != null ? this.effects[hit.attack.uid].status : Status.getStatus('normal');
      newStatus = resist.status;
      cumulativeStatuses = hit.attack.cumulativeStatuses;
      if ((_ref = curStatus.key, __indexOf.call(cumulativeStatuses, _ref) >= 0) && (_ref1 = newStatus.key, __indexOf.call(cumulativeStatuses, _ref1) >= 0)) {
        newStatus = hit.attack.statusByDegree(curStatus.degree + newStatus.degree);
      }
      if (newStatus.degree > curStatus.degree) {
        return addEffect(new CharacterEffect({
          attack: hit.attack,
          defense: resist.defense,
          status: newStatus
        }));
      }
    };

    Character.prototype.addEffect = function(effect) {
      this.effects[effect.attack.uid] = effect;
      return this.updateStatus();
    };

    Character.prototype.endRoundRecovery = function() {
      var changed, effect, k, resistance, _ref;
      changed = false;
      _ref = this.effects;
      for (k in _ref) {
        if (!__hasProp.call(_ref, k)) continue;
        effect = _ref[k];
        if (!effect.attack.isStatusRecovery || effect.status.degree < 1 || effect.status.degree > 2) {
          continue;
        }
        resistance = this.checkDegree(effect.attack.rank + 10, this.rollCheck(effect.defense.save));
        if (resistance > 0) {
          changed = true;
          effect.status = Status.getStatus('normal');
        } else if (effect.attack.isProgressive) {
          changed = true;
          effect.status = effect.attack.statusByDegree(effect.status.degree + 1);
        }
      }
      if (changed) {
        return this.updateStatus;
      }
    };

    return Character;

  })(Modifiable);

  module.exports = {
    Character: Character,
    CharacterEffect: CharacterEffect
  };

  Modifiable = require('./modifiable.coffee').Modifiable;

  utils = require('./utils.coffee').utils;

  Status = require('../src/status.coffee').Status;

  ResistResult = (function(_super) {

    __extends(ResistResult, _super);

    function ResistResult(values) {
      var properties;
      if (values == null) {
        values = {};
      }
      properties = {
        defense: null,
        d20: 0,
        roll: 0,
        degree: 4,
        stress: 0,
        status: Status.getStatus('normal')
      };
      ResistResult.__super__.constructor.call(this, null, properties, values);
    }

    return ResistResult;

  })(Modifiable);

  Defense = (function(_super) {

    __extends(Defense, _super);

    function Defense(values) {
      var modifiable;
      if (values == null) {
        values = {};
      }
      modifiable = {
        value: 10,
        save: 10,
        impervious: null
      };
      Defense.__super__.constructor.call(this, modifiable, null, values);
    }

    Defense.prototype.resistHit = function(hit, stress) {
      var damage, resist;
      resist = new ResistResult({
        defense: this
      });
      if (hit.degree < 1) {
        return resist;
      }
      damage = hit.damage;
      if ((this.impervious != null) && this.impervious >= hit.damageImpervious) {
        if (!(hit.attack.penetrating != null) || hit.attack.penetrating < 1) {
          return resist;
        }
        damage = Math.min(hit.attack.penetrating, hit.damage);
      }
      resist.d20 = this.rollCheck();
      resist.roll = resist.d20 + this.save - stress;
      resist.degree = this.checkDegree(damage + 10, resist.roll);
      if (resist.d20 === 20) {
        resist.degree = utils.increaseDegree(resist.degree);
      }
      if (hit.attack.isCauseStress && resist.degree <= 1) {
        resist.stress = 1;
      }
      resist.status = hit.attack.statusByResistDegree(resist.degree);
      return resist;
    };

    return Defense;

  })(Modifiable);

  module.exports = {
    Defense: Defense,
    ResistResult: ResistResult
  };

  utils = require('./utils.coffee').utils;

  _ = require('underscore');

  Modifiable = (function() {

    function Modifiable(modifiable, properties, values) {
      this.rollCheck = __bind(this.rollCheck, this);

      this._applyModifiers = __bind(this._applyModifiers, this);
      this._modifiers = {
        rollCheck: []
      };
      this._modifiable(modifiable);
      this._properties(properties);
      this._values(values);
      this.uid = _.uniqueId("uid_");
    }

    Modifiable.prototype._modifiable = function(obj) {
      var k, v, _results,
        _this = this;
      if (obj != null) {
        _results = [];
        for (k in obj) {
          if (!__hasProp.call(obj, k)) continue;
          v = obj[k];
          _results.push((function(k, v) {
            _this._modifiers[k] = [];
            _this["_" + k] = v;
            return Object.defineProperty(_this, k, {
              get: function() {
                return this._applyModifiers(k, this["_" + k]);
              },
              set: function(v) {
                return this["_" + k] = v;
              },
              enumerable: true,
              configurable: true
            });
          })(k, v));
        }
        return _results;
      }
    };

    Modifiable.prototype._properties = function(obj) {
      var k, v, _results,
        _this = this;
      if (obj != null) {
        _results = [];
        for (k in obj) {
          if (!__hasProp.call(obj, k)) continue;
          v = obj[k];
          _results.push((function(k, v) {
            return _this[k] = v;
          })(k, v));
        }
        return _results;
      }
    };

    Modifiable.prototype._values = function(obj) {
      var k, v, _results,
        _this = this;
      if (obj != null) {
        _results = [];
        for (k in obj) {
          if (!__hasProp.call(obj, k)) continue;
          v = obj[k];
          _results.push((function(k, v) {
            if (!Object.prototype.hasOwnProperty.call(_this, k)) {
              throw new Error("Invalid property \'" + k + "\'");
            }
            return _this[k] = v;
          })(k, v));
        }
        return _results;
      }
    };

    Modifiable.prototype._applyModifiers = function(k, v) {
      var m, _i, _len, _ref;
      if (this._modifiers[k] != null) {
        _ref = this._modifiers[k];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          m = _ref[_i];
          v = m.call(this, v);
        }
      }
      return v;
    };

    Modifiable.prototype.addModifier = function(k, m) {
      if (!(this._modifiers[k] != null)) {
        throw new Error("'" + k + "' cannot be modified");
      }
      return this._modifiers[k].push(m);
    };

    Modifiable.prototype.clearModifiers = function(k) {
      var key, value, _ref, _results;
      if (k != null) {
        if (this._modifiers[k] != null) {
          return this._modifiers[k] = [];
        }
      } else {
        _ref = this._modifiers;
        _results = [];
        for (key in _ref) {
          if (!__hasProp.call(_ref, key)) continue;
          value = _ref[key];
          _results.push(this.clearModifiers(key));
        }
        return _results;
      }
    };

    Modifiable.prototype.rollCheck = function(bonus) {
      if (bonus == null) {
        bonus = 0;
      }
      return this._applyModifiers('rollCheck', utils.rollD20(bonus));
    };

    Modifiable.prototype.checkDegree = function(difficulty, check) {
      return utils.checkDegree(difficulty, check);
    };

    return Modifiable;

  })();

  module.exports = {
    Modifiable: Modifiable
  };

  _ = require('underscore');

  StatusModifier = (function() {

    function StatusModifier(group, property, modifier, description) {
      this.group = group;
      this.property = property;
      this.modifier = modifier;
      this.description = description;
    }

    return StatusModifier;

  })();

  Status = (function() {

    Status.STATUSES = null;

    function Status(value) {
      var def;
      if (value == null) {
        value = {};
      }
      def = {
        key: 'normal',
        degree: 0,
        recovery: false,
        replace: null,
        modifiers: null
      };
      value = _.extend(def, value);
      this.key = value.key;
      this.degree = value.degree;
      this.recovery = value.recovery;
      this.replace = value.replace;
      this.modifiers = value.modifiers;
      Status.STATUSES[this.key] = this;
    }

    Status.getStatus = function(s) {
      var v;
      if (s instanceof Status) {
        return s;
      } else if (_.isString(s)) {
        v = Status.STATUSES[s];
        if (!(v != null)) {
          throw new Error("Invalid status '" + s + "'");
        }
        return v;
      } else {
        return null;
      }
    };

    Status.combinedStatus = function(value) {
      var degrees, k, m, max, modifiers, status, statuses, _i, _len, _ref;
      statuses = Status._doExpandStatuses(value);
      modifiers = [];
      degrees = [];
      for (k in statuses) {
        if (!__hasProp.call(statuses, k)) continue;
        status = statuses[k];
        degrees.push(status.degree);
        if (_.isArray(status.modifiers)) {
          _ref = status.modifiers;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            m = _ref[_i];
            if (_.isArray(m)) {
              modifiers.push((function(func, args, ctor) {
                ctor.prototype = func.prototype;
                var child = new ctor, result = func.apply(child, args);
                return Object(result) === result ? result : child;
              })(StatusModifier, m, function(){}));
            }
          }
        }
      }
      max = degrees.length > 0 ? Math.max.apply(Math, degrees) : 0;
      return {
        'statuses': statuses,
        'modifiers': modifiers,
        'degree': max
      };
    };

    Status.expandStatuses = function(value) {
      return Status.combinedStatus(value)['statuses'];
    };

    Status.allModifiers = function(value) {
      return Status.combinedStatus(value)['modifiers'];
    };

    Status.degree = function(value) {
      return Status.combinedStatus(value)['degree'];
    };

    Status._doExpandStatuses = function(value) {
      var k, r, replacing, result, status, v, _i, _j, _len, _len1, _ref;
      if (_.isObject(value && !_.isArray(value && !_.isFunction(value)))) {
        value = _.values(value);
      }
      if (!_.isArray(value)) {
        value = [value];
      }
      result = {};
      for (_i = 0, _len = value.length; _i < _len; _i++) {
        v = value[_i];
        status = Status.getStatus(v);
        if (!(status != null) || (result[status.key] != null)) {
          continue;
        }
        result[status.key] = status;
        if (_.isArray(status.modifiers)) {
          result = _.extend(result, Status._doExpandStatuses(status.modifiers));
        }
      }
      for (k in result) {
        if (!__hasProp.call(result, k)) continue;
        v = result[k];
        if (v.replace != null) {
          replacing = v.replace;
        }
      }
      if (replacing != null) {
        _ref = _.flatten(replacing);
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          r = _ref[_j];
          delete result[r];
        }
      }
      if (_.keys(result).length < 1) {
        result['normal'] = Status.getStatus('normal');
      }
      if ((result['normal'] != null) && _.keys(result).length > 1) {
        delete result['normal'];
      }
      return result;
    };

    Status._init = function() {
      var s, standardStatuses, _i, _len, _results;
      if (Status.STATUSES !== null) {
        return;
      }
      Status.STATUSES = {};
      standardStatuses = [
        {
          key: 'normal',
          degree: 0,
          recovery: false,
          replace: null,
          modifiers: null
        }, {
          key: 'compelled',
          degree: 2,
          recovery: false,
          replace: null,
          modifiers: ['actionPartial', 'actionsControlled']
        }, {
          key: 'controlled',
          degree: 3,
          recovery: false,
          replace: ['compelled'],
          modifiers: ['actionsControlled']
        }, {
          key: 'dazed',
          degree: 1,
          recovery: false,
          replace: null,
          modifiers: ['actionPartial']
        }, {
          key: 'debilitated',
          degree: 3,
          recovery: false,
          replace: ['disabled', 'weakened'],
          modifiers: ['actionNone']
        }, {
          key: 'defenseless',
          degree: 2,
          recovery: false,
          replace: ['vulnerable'],
          modifiers: [
            [
              'defense', 'value', (function(x) {
                return 0;
              }), 'defenseless'
            ]
          ]
        }, {
          key: 'disabled',
          degree: 2,
          recovery: false,
          replace: ['impaired'],
          modifiers: [
            [
              'ALL', 'rollCheck', (function(x) {
                return x - 5;
              }), 'disabled; -5 to checks'
            ]
          ]
        }, {
          key: 'fatigued',
          degree: 1,
          recovery: false,
          replace: null,
          modifiers: ['hindered']
        }, {
          key: 'hindered',
          degree: 1,
          recovery: false,
          replace: null,
          modifiers: [
            [
              'character', 'speed', (function(x) {
                return x - 1;
              }), 'hindered: -1 speed'
            ]
          ]
        }, {
          key: 'immobile',
          degree: 2,
          recovery: false,
          replace: ['hindered'],
          modifiers: [
            [
              'character', 'speed', (function(x) {
                return null;
              }), 'immoble: no speed'
            ]
          ]
        }, {
          key: 'impaired',
          degree: 1,
          recovery: false,
          replace: null,
          modifiers: [
            [
              'ALL', 'rollCheck', (function(x) {
                return x - 2;
              }), 'impaired; -2 to checks'
            ]
          ]
        }, {
          key: 'stunned',
          degree: 2,
          recovery: false,
          replace: ['dazed'],
          modifiers: ['actionNone']
        }, {
          key: 'transformed',
          degree: 3,
          recovery: false,
          replace: null,
          modifiers: ['actionNone']
        }, {
          key: 'unaware',
          degree: 3,
          recovery: false,
          replace: null,
          modifiers: ['actionNone']
        }, {
          key: 'vulnerable',
          degree: 1,
          recovery: false,
          replace: null,
          modifiers: [
            [
              'defense', 'value', (function(x) {
                return Math.ceil(x / 2.0);
              }), 'vulnerable: 1/2 defense'
            ]
          ]
        }, {
          key: 'weakened',
          degree: 1,
          recovery: false,
          replace: null,
          modifiers: null
        }, {
          key: 'asleep',
          degree: 3,
          recovery: false,
          replace: null,
          modifiers: ['defenseless', 'stunned', 'unaware']
        }, {
          key: 'blind',
          degree: 2,
          recovery: false,
          replace: null,
          modifiers: ['hindered', 'unaware', 'vulnerable', 'impaired']
        }, {
          key: 'bound',
          degree: 2,
          recovery: false,
          replace: null,
          modifiers: ['defenseless', 'immobile', 'impaired']
        }, {
          key: 'deaf',
          degree: 2,
          recovery: false,
          replace: null,
          modifiers: ['unaware']
        }, {
          key: 'dying',
          degree: 4,
          recovery: false,
          replace: null,
          modifiers: ['incapacitated']
        }, {
          key: 'entranced',
          degree: 1,
          recovery: true,
          replace: null,
          modifiers: ['actionNone']
        }, {
          key: 'exhausted',
          degree: 2,
          recovery: false,
          replace: ['fatigued'],
          modifiers: ['impaired', 'hindered']
        }, {
          key: 'incapacitated',
          degree: 3,
          recovery: false,
          replace: null,
          modifiers: ['defenseless', 'stunned', 'unaware', 'prone']
        }, {
          key: 'paralyzed',
          degree: 3,
          recovery: false,
          replace: null,
          modifiers: ['defenseless', 'immobile', 'stunned']
        }, {
          key: 'prone',
          degree: 2,
          recovery: false,
          replace: null,
          modifiers: [
            'hindered', [
              'defense', 'value', (function(x) {
                return x - 5;
              }), 'prone: -5 defense'
            ]
          ]
        }, {
          key: 'restrained',
          degree: 2,
          recovery: false,
          replace: null,
          modifiers: ['hindered', 'vulnerable']
        }, {
          key: 'staggered',
          degree: 2,
          recovery: false,
          replace: null,
          modifiers: ['dazed', 'hindered']
        }, {
          key: 'suprised',
          degree: 1,
          recovery: true,
          replace: null,
          modifiers: ['stunned', 'vulnerable']
        }, {
          key: 'actionPartial',
          degree: 0,
          recovery: false,
          replace: null,
          modifiers: [
            [
              'character', 'actions', (function(x) {
                return 'partial';
              }), 'partial actions'
            ]
          ]
        }, {
          key: 'actionNone',
          degree: 0,
          recovery: false,
          replace: ['actionPartial'],
          modifiers: [
            [
              'character', 'actions', (function(x) {
                return 'none';
              }), 'no actions'
            ]
          ]
        }, {
          key: 'actionsControlled',
          degree: 0,
          recovery: false,
          replace: null,
          modifiers: [
            [
              'character', 'isControlled', (function(x) {
                return true;
              }), 'actions controlled'
            ]
          ]
        }
      ];
      _results = [];
      for (_i = 0, _len = standardStatuses.length; _i < _len; _i++) {
        s = standardStatuses[_i];
        _results.push(new Status(s));
      }
      return _results;
    };

    return Status;

  })();

  Status._init();

  module.exports = {
    Status: Status,
    StatusModifier: StatusModifier
  };

  _ = require('underscore');

  Utils = (function() {

    function Utils() {}

    Utils.rollD20 = function(bonus) {
      if (bonus == null) {
        bonus = 0;
      }
      return Math.floor(Math.random() * 20) + 1 + bonus;
    };

    Utils.checkDegree = function(difficulty, check) {
      var result;
      result = check - difficulty;
      return Math.floor(result / 5) + (result < 0 ? 0 : 1);
    };

    Utils.increaseDegree = function(degree, inc) {
      var isNeg;
      if (inc == null) {
        inc = 1;
      }
      isNeg = degree < 0;
      degree += inc;
      if (isNeg && degree >= 0) {
        return degree + 1;
      } else {
        return degree;
      }
    };

    Utils.makeArray = function(obj) {
      if (!(obj != null)) {
        return [];
      } else if (_.isArray(obj)) {
        return obj;
      } else {
        return [obj];
      }
    };

    return Utils;

  })();

  module.exports = {
    utils: Utils
  };

}).call(this);
